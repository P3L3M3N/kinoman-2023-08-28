# Критерии

Подготовка и проверка личных проектов проводится
по базовым и дополнительным критериям.
Базовые критерии охватывают наиболее важные
требования к проекту и проверяют основные знания
и навыки. Для успешной защиты личного проекта
должны быть выполнены все базовые критерии.
Дополнительные критерии проверяют то, насколько
студент внимателен к деталям, и оценивают проект
с точки зрения шлифовки его качества и оптимизации.
Выполнение этих критериев необходимо для защиты
на 100%.

Во время финальной защиты баллы за выполнение
дополнительных критериев добавляются только при
выполнении всех базовых

## Базовые

#### Б1. 
Код соответствует техническому заданию проекта.
Все обязательные пункты технического задания выполнены.

#### Б2. 
При выполнении кода не возникает необработанных ошибок.
При открытии диалогов, загрузке данных и работе с
сайтом не возникает ошибок, программа не
ломается и не зависает.

## Именование

#### Б3. 
Название переменных, параметров, свойств и
методов начинается со строчной буквы и
записываются в нотации lowerCamelCase.
Исключение составляют перечисления, они
записываются в нотации CamelCase.
Критерий касается как переменных, объявленных
пользователем, так и полученных извне.
Такие данные нужно адаптировать. Например, руками:

 ```JS
fetch(`https://my-site.fake/api/user`)
    .then((response) => response.json())
    .then(({ user_name: userName, user_age:
        userAge }) => ({
            userName,
            userAge
        }));
```

Но лучше написать для этого отдельную функцию.

#### Б4. 
Для названия значений используются английские 
существительные.Сокращения в словах запрещены. 
Сокращённые названия переменных можно использовать, 
только если такое название широко распространено.

**Допустимые сокращения:**

- `evt` для объектов `Event` и его производных
    (`MouseEvent`, `KeyboardEvent` и подобные)
- `i`, `j`, `k`, `l`, `t` для счётчика в цикле, `j` для
    счётчика во вложенном цикле и так далее по
    алфавиту
- `cb` для единственного колбэка в параметрах
    функции
- Допустимо именовать переменные-предикаты
- 
- флаги или функции, которые возвращают булево
значение — по схеме `«is + признак»`.
**Например**

```JS
const isLoading = true;
const isChecked = (checkboxes) =>
    checkboxes.some((checkbox) =>
        checkbox.checked);
```

Использовать data для аргумента с данными
запрещено. Название должно быть осмысленным.

⛔️ **Неправильно:** 

```JS
const getFilterMarkup = (data) => {

    return data.map(
        (i) => <label><input type="radio"
            name="filter-${i.id}" />${i.name}</label>
    ).join(``);
};
```

✅ **Правильно:**

```JS
const getFilterMarkup = (filters) => {

    return filters.map(
        (filter) => <label><input type="radio"
            name="filter-${filter.id}" />${filter.name}</label>
    ).join(``);
};
```

#### Б5.
Названия констант (постоянных значений)
написаны прописными (заглавными) буквами.

Слова разделяются подчёркиваниями
(UPPER_SNAKE_CASE), **например:**

```JS
const MAX_HEIGHT = 400 ;
const EARTH_RADIUS = 6370 ;
```

#### Б6. 
Классы названы английскими существительными.
Название класса начинается с заглавной буквы.

⛔️ **Неправильно:**
```JS 
class wizard {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
class Run {
    constructor() {
        console.log(`О, я бегу!`);
    }
}
```

✅ **Правильно**
```JS
class Wizard {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
class Runner {
    constructor() {
        console.log(`О, я бегун!`);
    }
}
```

#### Б7. 
Перечисления (Enum) названы английскими
существительными и начинаются с прописной
(заглавной) буквы.

Перечисления начинаются с прописной (заглавной)
буквы. Перечисления названы существительными в
единственном числе. Значения перечислений
объявлены как константы.

⛔️ **Неправильно:**
```JS
const view = {
    artist: Artist,
    genre: Genre,
};
const EndGameType = {
    lives: `lives`,
    quests: `quests`,
};
```

✅ **Правильно**
```JS
const View = {
    ARTIST: Artist,
    GENRE: Genre,
};
const EndGameType = {
    LIVES: `lives`,
    QUESTS: `quests`,
};
```

#### Б8. 
Массивы названы существительными во множественном числе.

⛔️ **Неправильно:**
```JS
const age = [12, 40, 22, 7];

const name = [`Иван`, `Петр`, `Мария`, `Алексей`];

const wizard = {
    name: `Гендальф`,
    friend: [`Саурон`, `Фродо`, `Бильбо`]
};
```

✅ **Правильно:**
```JS
const ages = [12, 40, 22, 7];

const names = [`Иван`, `Петр`, `Мария`, `Алексей`];

const wizard = {
    name: `Гендальф`,
    friends: [`Саурон`, `Фродо`, `Бильбо`]
};
```

#### Б9. 
В названии переменных не используется тип данных.

⛔️ **Неправильно:**
```JS
const filtersArray = [`All`, `Past`, `Feature`];
const wizardObject = {
    name: `Гендальф`,
    age: 386
};
```

✅ **Правильно:**
```JS
const filters = [`All`, `Past`, `Feature`];
const wizard = {
    name: `Гендальф`,
    age: 386
};
```

#### Б10. 
Название функции или метода содержит глагол.

Название функции или метода должно быть
глаголом и соответствовать действию, которое
выполняет функция или метод. Например, можно
использовать глагол `get` для функций или методов,
которые что-то возвращают.
Исключение функции-обработчики (см. критерий Из
названия обработчика события и функции-колбэка
следует, что это обработчик). 
Исключение справедливо только для выполнения
дополнительного критерия.

⛔️ **Неправильно:**
```JS
const function1 = (names) => {
    names.forEach((name) => {
        console.log(name);
    });
};

const wizard = {
    name: `Гендальф`,
    action() {
        console.log(`Стреляю файрболлом!`);
    }
};

const randomNumber = () => {
    return Math.random();
};
```

✅ **Правильно:**
```JS
const printNames = (names) => {
    names.forEach((name) => {
        console.log(name);
    });
};

const wizard = {
    name: `Гендальф`,
    fire() {
        console.log(`Стреляю файрболлом!`);
    }
};

const getRandomNumber = () => {
    return Math.random();
};
```

#### Б11. 
Названия файлов модулей записаны строчными 
(маленькими) буквами. Слова разделены дефисами.
Для того, чтобы избежать конфликтов имён в разных
операционных системах, лучше применять
наименее конфликтный способ именования файлов
— строчными (маленькими) буквами через дефис.

## Форматирование и внешний вид 

#### Б12. 
Неизменяемые значения объявленычерез const.

При объявлении новых значений предпочтение
стоит отдавать использованию ключевого
слова const. Использовать let нужно только в том
случае, если значение будет перезаписано.

⛔️ **Неправильно:**
```JS
let a = 1;
let b = 2;
let sum = a + b;
```

✅ **Правильно:**
```JS
const a = 1;
const b = 2;
const sum = a + b;

for (let i = 0; i < 42; i++) {
    console.log(i);
}
```

⛔️ **Неправильно:**
```JS
let level = getLevel(this.state.level, this.quest);
let answerNames = Object.keys(level.answers);
let answers = answerNames.map((key) => ({
    key,
    value: level.answers[key]
}));
```

✅ **Правильно:**
```JS
const level = getLevel(this.state.level, this.quest);
const answerNames = Object.keys(level.answers);
const answers = answerNames.map((key) => ({
    key, 
    value: level.answers[key]
}));
```

#### Б13. 
Используются обязательные блоки кода.

В любых конструкциях, где подразумевается
использование блока кода (фигурных скобок), таких
как `for`, `while`, `if`, `switch`, `function`, блок кода
используется обязательно, даже если инструкция
состоит из одной строчки.
⛔️ **Неправильно:**
```JS
(() => {
  if (x % 2 === 1) return;
})();
```

✅ **Правильно:**
```JS
(() => {
  if (x % 2 === 1) {
    return;
  }
})();
```

Исключения составляют однострочные стрелочные
функции, которые можно использовать без
обязательных блоков кода:
```JS
const checkedCheckBoxes = checkboxes.filter((checkbox) => checkbox.checked);
```

#### Б14. 
Код всех JS-файлов соответствует рекомендованной структуре.
✅ **Рекомендованная структура:**

1. Импорты
```JS
import intersection from 'lodash/intersection';
```
2. Объявление констант
```JS
const DEFAULT_COLORS = [`red`, `green`, `blue`];
```
3. Объявление переменных, значение которых 
   известно до начала работы программы
```JS
const colorPicker = document.querySelector(`.color-picker`);
```
4. Объявление функций
```JS
const getColorsIntersection = (userColors, defaultColors) => {
  return intersection(userColors, defaultColors);
};
```
5. Код программы. Вызов функций, использование 
ранее объявленных переменных,объявление класса.
Объявление вычисляемых переменных
```JS
const rightColors = getColorsIntersection(colorPicker.value, DEFAULT_COLORS);
```
6. Экспорты
```JS
export {rightColors};
```
Некоторые блоки могут отсутствовать, но
оставшиеся всё равно должны придерживаться
порядка.
Не допускается использование экспорта в момент
объявления переменной. Исключения:
- прямой экспорт значений по умолчанию;
- модули с утилитарными функциями и константами. 
  В них все значения должны быть экспортированы 
  с помощью именованного экспорта.

#### Б15. 
Код соответствует гайдлайнам.

- Отступы между операторами и ключевым
  словами соответствуют стайлгайду.
- Для отступов используются одинаковые
  символы, вложенность кода обозначается
  отступами.
- Однообразно расставлены пробелы перед,
  после и внутри скобок, операторов и ключевых
  слов.

 **Указания к проверке**
Не возникает ошибок при проверке проекта
ESLint: `npm i && npm test.`

#### Б16.
Сложные составные константы собираются в перечисления Enum.
Множества однотипных констант собираются в перечисления.

⛔️ **Неправильно:**
```JS
const COLOR_SUCCESS = `#00FF00`;
const COLOR_WARNING = `#FF9900`;
const COLOR_DANGER = `#FFFF00`;
```

✅ **Правильно:**
```JS
const Color = {
 SUCCESS: `#00FF00`,
 WARNING: `#FF9900`,
 DANGER: `#FFFF00`
 };
```

Не стоит путать перечисления с обычными
объектами или объектами-неймспейсами, например:
```JS
const helpers = {
  getRandom() { /* ... */ },
  getSubArray() { /* ... */ },
};

const Wizard = {
  width: 10,
  beard: true,
  eyesColor: `blue`
};
```

#### Б17. 
Приватные поля в классах помечены и не используются снаружи.
Названия методов, которые есть в классе, но не
предназначены для внешнего использования,
начинаются с нижнего подчёркивания `_`. Доступ к
таким полям извне класса запрещён.

## Мусор

#### Б18. 
В коде проекта нет файлов и частей кода,
которые не используются, включая
закомментированные участки кода.

#### Б19. 
Версии используемых зависимостей
зафиксированы в `package.json`.
В списках зависимостей в
файле `package.json` указаны точные версии
используемых пакетов. Версия обязательно должна
быть указана. Не допускается
использование , `*` и `~`.

#### Б20. 
В коде нет заранее недостижимых участков кода.

⛔️ **Невыполнимые условия:**
```JS
const happen = false;
if (happen) {
  console.log(`This will not happen anyway!`);
}
```
⛔️ **Операции после выхода из функции:**
```JS
(() => {
  return;
  console.log(`This will not happen!`);
})();
```

## Корректность 

#### Б21. 
Константы и перечисления нигде в коде не
переопределяются.
Константы и перечисления (enum) используются
только для чтения и никогда не переопределяются
на всём промежутке жизни программы.

#### Б22. 
Используются строгие сравнения вместо нестрогих.
Вместо операторов нестрогого сравнения `==` и `!=` 
используются операторы строгого сравнения `===`, `!==`. 
[Таблицы истинности для JavaScript](https://dorey.github.io/JavaScript-Equality-Table/).

⛔️ **Неправильно:**
```JS
const foo = ``;
const bar = [];
if (foo == bar) {
  destroy(world);
}
```

✅ **Правильно:**
```JS
const foo = ``;
const bar = [];
if (foo === bar) {
  destroy(world);
}
```

#### Б23. 
В коде не используются зарезервированные
слова в качестве имён переменных и свойств.
В названия переменных и свойств не включаются
операторы и ключевые слова, зарезервированные
для будущих версий языка (например, `class`, `extends`). 
Список всех зарезервированных слов можно найти [тут](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords).

#### Б24. 
Отсутствуют потенциально некорректные операции.
Например, некорректное сложение двух операндов
как строк. Проблема приоритета конкатенации над
сложением.

⛔️ **Неправильно:**
```JS
new Date() + 1000 ;
```

✅ **Правильно:**
```JS
Number(new Date()) + 1000 ;
```

Некорректные проверки на существование с числами. 
Пример некорректной проверки на то, что
переменная является числом:
```JS
const double = (value) => {
  if (!value) {
    return NaN;
  }

  return value * 2;
};

double(0);
double();
double(5);
```

Потенциально некорректная операция взятия целой
части числа.

⛔️ **Неправильно:**
```JS
const minutesNumber = ~~(seconds / 60 );
```

✅ **Правильно:**
```JS
const minutesNumber = Math.trunc(seconds / 60 );
```

## Модульность

#### Б25. 
Все файлы JS представляют собой отдельные модули ES2015.
Экспорт и импорт значений производится при
помощи ключевых слов export и import.
Сохранение в глобальную область видимости
значений не допускается.

✅ **Пример правильного модуля:**
```JS
import {changeView} from '../util';
import WelcomeView from './welcome-view';
import App from '../main';
export default class Welcome {
  constructor() {
    this.view = new WelcomeView();
  }

  init() {
    changeView(this.view);

    this.view.onStart = () => {
      App.showGame();
    };
  }
}
```

#### Б26. 
Модули не экспортируют изменяющиеся переменные.
Модуль не должен экспортировать переменную,
значение которой может измениться в будущем.

⛔️ **Неправильно:**
```JS
export let latestResult;
```

✅ **Правильно:**
```JS 
export const latestResult = loadLatestResult();
```

#### Б27. 
Название модуля соответствует его содержимому.
Разные логические части кода вынесены в
отдельные файлы модулей. Имя модуля должно
соответствовать его содержимому. Например, если
в модуле лежит класс GameView, то и имя модуля
должно быть `game-view.js`.

#### Б28. 
Из одного модуля экспортируется не больше одного класса. 
Класс всегда экспортируется как `default`.

## Универсальность

#### Б29. 
Код является кроссбраузерным и не вызывает ошибок в 
разных браузерах и разных операционных системах.
При проверке этого критерия необходимо
удостовериться в правильной работе и отсутствии
сообщений об ошибках в выполняемых скриптах в
браузерах Chrome, Firefox, Safari.

**Указания к проверке**
Допустимое исключение в кроссбраузерности кода:
валидация форм в Safari. Safari плохо поддерживает
работу с валидацией, например, не показывает
ошибку, если при отправке формы не введены
данные в поле с атрибутом `required`, поэтому
небольшие ошибки, связанные с валидацией в
Safari можно проигнорировать. Тестирование
необходимо проводить именно в последних версиях
браузеров, которые предоставляют поставщики, а
не в тех, которые установлены в данный момент на
компьютере проверяющего.

## Магия

#### Б30. 
Нельзя пользоваться глобальной переменной `event`.

⛔️ **Приводит к неосознанному коду:**
```JS
const elem = document.querySelector(`.test`);
const onElemClick = () => {
  event.target.innerText = `you really need
    event`;
};

elem.addEventListener(`click`, oneElemClick);
```

#### Б31. 
В коде не используются «магические значения», 
под каждое из них заведена отдельная переменная, 
названная как константа.

## Оптимальность

#### Б32. 
Своевременный выход из цикла: цикл не работает дольше, чем нужно.

⛔️ **Неправильно:**
```JS
apartments.forEach((it, index) => {
  if (index < 3) {
    render(it);
  }
});
```

✅ **Правильно:**
```JS
for (let i = 0; i < Math.min(apartments.length, 3); i++) {
  render(apartments[i]);
}
```

#### Б33. 
Внутри шаблонов-строк (template literals) не используется конкатенация строк.

Конкатенация строк в шаблонных строках является
антипаттерном, так как ухудшает читаемость
шаблонной строки.

⛔️ **Неправильно:**
```JS
const page = `${header + `\n` + main + `\n` + footer}`;
```

✅ **Правильно:**
```JS
const page = `${header}\n${main}\n${footer}`;
```

Не забывайте, что внутри шаблонных строк можно
использовать обратные апострофы:
```JS
const genreMarkup = `${genres.length > 1 ? `Genres` : `Genre`}`;
```

#### Б34. 
Количество вызовов циклов минимизировано.
Если задачу можно решить за один проход по циклу,
вместо нескольких она должна быть решена за один.

⛔️ **Неправильно:**
```JS
const wizardNames = source.
  map((it) => it.wizard).
  map((it) => it.name);
```

✅ **Правильно:**
```JS
const wizardNames = source.map((it) => it.wizard.name);
```

Допускается использовать цепочку разных методов.
Например:
```JS
[].map(() => {}).filter(() => {});
```

#### Б35. 
Множественные DOM-операции производятся на элементах, которые не добавлены в DOM.
Например, наполнение скопированного из шаблона элемента данными.

## Безопасность

#### Б36. 
Обработчики события добавляются и удаляются своевременно.
Обработчики событий для виджетов добавляются
только в момент появления виджета на странице и
удаляются в момент их исчезновения.

**Защита от memory-leak**
Кол-во обработчиков, подвешенных на глобальную
область видимости, не должно возрастать.
Например, если подвешивается обработчик,
который следит за перемещением курсора по
экрану, то он должен подвешиваться и
отвешиваться в нужный момент. В случае, если
обработчик на `document` только подвешивается, это
может свидетельствовать о проблеме бесконечного
создания обработчиков и потенциальной утечке памяти.

**Защита от неправильного поведенияинтерфейса**
Например, на странице может существовать попап,
который скрывается по `ESC`. Лучше для него гасить
обработчик, если он не показан, потому что он
может каким-то образом ломать поведение сайта —
останавливать распространение, отменять
поведение по умолчанию и так далее. Поэтому
поведение должно быть явным — если в этот
момент времени обработчики не нужны, их нужно
удалить. Явное и предсказуемое поведение.

#### Б37. 
Запрещено вставлять в `innerHTML` и подобные
ему свойства и методы строки, полученные снаружи
(пользовательский ввод, данные сервера), без
применения экранирования.

Защита от XSS-атак, а также изменения исходных
данных, запутывание пользователя и прочее. Перед
вставкой необходимо провести экранирование,
например, с помощью `DOMPurify`.

⛔️ **Неправильно:** 

через `innerHTML `вставляются данные,
которые невозможно полностью контролировать,
без предварительного экранирования. Это может
быть пользовательский ввод, который может содержать XSS.
```JS
const listItem = listItemTemplate.cloneNode(true);
listItem.querySelector(`.title`).innerHTML = user.fullName;

```

✅ **Правильно:** 
проводить экранирование при вставке внешних данных.
```JS
const listItem = listItemTemplate.cloneNode(true);
listItem.querySelector(`.title`).innerHTML = DOMPurify.sanitize(user.fullName);
```

✅ **Правильно:** 
```JS
вставлять данные, которые полностью созданы программистом.
const listItemTemplate = `<li class="amenity><i></i><a href="#"></a></li>`;
list.innerHTML = listItemTemplate;
```
